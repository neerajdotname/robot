(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';

        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';

        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }

        var n = loadNodeModulesSync(x, y);
        if (n) return n;

        throw new Error("Cannot find module '" + x + "'");

        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }

            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }

        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }

            return loadAsFileSync(x + '/index');
        }

        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }

            var m = loadAsFileSync(x);
            if (m) return m;
        }

        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');

            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }

            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);

    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);

    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;

    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }

        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;

        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };

        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",function(require,module,exports,__dirname,__filename,process,global){function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

});

require.define("__browserify_process",function(require,module,exports,__dirname,__filename,process,global){var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
        && window.setImmediate;
    var canPost = typeof window !== 'undefined'
        && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'browserify-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('browserify-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    if (name === 'evals') return (require)('vm')
    else throw new Error('No such module. (Possibly not yet loaded)')
};

(function () {
    var cwd = '/';
    var path;
    process.cwd = function () { return cwd };
    process.chdir = function (dir) {
        if (!path) path = require('path');
        cwd = path.resolve(dir, cwd);
    };
})();

});

require.define("/robot.animation.js",function(require,module,exports,__dirname,__filename,process,global){/*jshint node:true jquery:true*/
"use strict";

module.exports = function(robot) {
	robot.RobotAnimation = function() { return this.init.apply(this, arguments); };
	robot.RobotAnimation.prototype = {
		init: function($robot, $maze, blockSize) {
			this.$robot = $robot;
			this.$maze = $maze;
			this.blockSize = blockSize;

			this.scale = blockSize/64+0.01;
			if (this.blockSize !== 64) {
				robot.setCss3(this.$robot[0], 'transform', 'scale(' + this.scale + ')');
			}
			
			this.rotationFactor = 0.75;
			this.detectWallLength = 40000;
			this.animationQueue = [];
			this.duration = 0.006;
			this.animateTimeout = null;
			this.blinkTimeouts = [];
			this.currentAnimation = null;
			this.lastNumber = 0;
			this.animationString = '';
			this.playing = false;
		},

		add: function(anim) {
			if (anim.type === 'movement') {
				var dx = (anim.x2-anim.x)*this.blockSize, dy = (anim.y2-anim.y)*this.blockSize;
				anim.length = Math.sqrt(dx*dx + dy*dy);
				if (anim.length <= 0) return;
			} else if (anim.type === 'rotation') {
				anim.length = Math.abs(anim.angle2-anim.angle);
				if (anim.length <= 0) return;
			}
			this.animationQueue.push(anim);
			this.addAnimationString(anim);
		},

		playAnimation: function(number) {
			this.playing = true;
			this.clearTimeout();
			this.number = number;
			var animation = this.animationQueue[this.number];
			this.setInitial(animation);

			if (animation.type === 'wall') {
				this.setLight(animation.wall ? 'red' : 'green');
				this.animateTimeout = setTimeout(this.animationEnd.bind(this), this.duration*this.detectWallLength);
			} else if (animation.type === 'delay') {
				this.animateTimeout = setTimeout(this.animationEnd.bind(this), this.duration*animation.length);
			} else {
				this.animateTimeout = setTimeout(this.animationStart.bind(this), 0);
			}
		},

		play: function(start, end) {
			if (start >= 0 && this.animationQueue.length > 0) {
				if (end > start) {
					this.lastNumber = end;
					this.playAnimation(start);
				} else {
					this.playing = false;
					if (start < this.animationQueue.length) {
						this.setInitial(this.animationQueue[start]);
					} else {
						var animation = this.animationQueue[this.animationQueue.length-1];
						this.resetRobot();
						this.setPosition(animation.x2 || animation.x, animation.y2 || animation.y);
						this.setOrientation(animation.angle2 || animation.angle);
						this.setLight('default');
						this.show();
					}
					this.clearTimeout();
				}
			} else {
				this.playing = false;
				this.clearTimeout();
				this.resetRobot();
				this.hide();
			}
		},

		stop: function() {
			this.clearTimeout();
			this.resetRobot();
			this.hide();
		},

		getLength: function() {
			return this.animationQueue.length;
		},

		remove: function() {
			this.clearTimeout();
			this.resetRobot();
			this.hide();
		},

		removeFromAnimNum: function(animNum) {
			this.clearTimeout();
			this.animationQueue = this.animationQueue.slice(0, animNum);
			this.animationString = '';
			for (var i=0; i<this.animationQueue.length; i++) {
				this.addAnimationString(this.animationQueue[i]);
			}
		},

		/// INTERNAL FUNCTIONS ///
		addAnimationString: function(anim) {
			if (anim.goals) {
				for (var i=0; i<anim.goals.length; i++) {
					this.animationString += 'G' + anim.goals[i].x + '/' + anim.goals[i].y + '/' + anim.goals[i].amount + ',';
				}
			}
			this.animationString += anim.type + ',' + anim.x + ',' + anim.y + ',' + anim.x2 + ',' + anim.y2 + ',' + anim.angle + ',' + anim.angle2 + ',';
		},

		resetRobot: function() {
			robot.setCss3(this.$robot[0], 'transition', '');
			this.$robot.off('transitionend webkitTransitionEnd MSTransitionEnd oTransitionEnd');
			this.$maze.children('.robot-maze-block-goal-blink').removeClass('robot-maze-block-goal-blink');
			for (var i=0; i<this.blinkTimeouts.length; i++) {
				clearTimeout(this.blinkTimeouts[i]);
			}
		},

		show: function() {
			this.$robot[0].style.display = 'block';
		},

		hide: function() {
			this.$robot[0].style.display = 'none';
		},

		setInitial: function(animation) {
			this.resetRobot();
			this.setPosition(animation.x, animation.y);
			this.setOrientation(animation.angle);
			this.setLight('default');
			this.show();
		},

		animationStart: function() {
			this.animateTimeout = null;
			var animation = this.animationQueue[this.number];
			var duration = (this.duration*animation.length).toFixed(5);
			//this.$robot.on('transitionend webkitTransitionEnd MSTransitionEnd oTransitionEnd', this.animationEnd.bind(this));
			this.animateTimeout = window.setTimeout(this.animationEnd.bind(this), duration*1000);

			if (animation.type === 'movement') {
				robot.setCss3(this.$robot[0], 'transition', 'left ' + duration + 's linear, top ' + duration + 's linear');
				this.setPosition(animation.x2, animation.y2);

				if (animation.goals !== null) {
					for (var i=0; i<animation.goals.length; i++) {
						this.setBlinkAnim(animation.goals[i].$block, animation.goals[i].amount);
					}
				}
			} else if (animation.type === 'rotation') {
				duration = this.rotationFactor*duration;
				robot.setCss3(this.$robot[0], 'transition', 'transform ' + duration + 's linear', true);
				this.setOrientation(animation.angle2);
			}
		},

		setBlinkAnim: function($block, amount) {
			this.blinkTimeouts.push(setTimeout(function() {
				$block.addClass('robot-maze-block-goal-blink');
			}, (amount-0.5)*this.blockSize*this.duration*1000));
			this.blinkTimeouts.push(setTimeout(function() {
				$block.removeClass('robot-maze-block-goal-blink');
			}, (amount+0.5)*this.blockSize*this.duration*1000));
		},

		animationEnd: function() {
			//this.clearTimeout();
			this.animateTimeout = null;
			this.setLight('default');

			if (this.number+1 < this.lastNumber && this.number < this.animationQueue.length-1) {
				this.playAnimation(this.number+1);
			} else {
				this.playing = false;
			}
		},

		setPosition: function(x, y) {
			this.$robot.css('left', Math.round(x*this.blockSize + this.blockSize/2));
			this.$robot.css('top', Math.round(y*this.blockSize + this.blockSize/2));
		},

		setOrientation: function(angle) {
			robot.setCss3(this.$robot[0], 'transform', 'rotate(' + Math.round(90-angle) + 'deg)' + (this.blockSize !== 64 ? ' scale(' + this.scale + ')' : ''));
		},

		setLight: function(state) {
			this.$robot.removeClass('robot-green robot-red');
			if (state === 'red') {
				this.$robot.addClass('robot-red');
			} else if (state === 'green') {
				this.$robot.addClass('robot-green');
			}
		},

		clearTimeout: function() {
			if (this.animateTimeout !== null) {
				clearTimeout(this.animateTimeout);
				this.animateTimeout = null;
			}
		}
	};
};
});

require.define("/robot.manager.js",function(require,module,exports,__dirname,__filename,process,global){/*jshint node:true jquery:true*/
"use strict";

module.exports = function(robot) {
	robot.RobotAnimationManager = function() { return this.init.apply(this, arguments); };
	robot.RobotAnimationManager.prototype = {
		init: function($robot, $maze, blockSize) {
			this.$robot = $robot;
			this.$robot.hide();
			this.$maze = $maze;
			this.blockSize = blockSize;
			this.runningAnimation = null;
			this.insertingAnimation = null;
			this.start = -1;
			this.end = -1;
		},

		newAnimation: function() {
			this.insertingAnimation = new robot.RobotAnimation(this.$robot, this.$maze, this.blockSize);
			return this.insertingAnimation;
		},
		
		play: function(start, end) {
			var newAnim = this.useNewAnimation();
			if (newAnim || this.start !== start || this.end !== end) {
				this.forcePlay(start, end);
			}
		},

		forcePlay: function(start, end) {
			this.useNewAnimation();
			this.start = start;
			this.end = end;
			this.replay();
		},

		replay: function() {
			if (this.runningAnimation !== null && this.start >= 0 && this.end >= 0) {
				this.runningAnimation.play(this.start, this.end);
			}
		},

		stop: function() {
			this.start = -1;
			this.end = -1;
			if (this.runningAnimation !== null) {
				this.runningAnimation.stop();
			}
		},

		remove: function() {
			if (this.runningAnimation !== null) {
				this.runningAnimation.remove();
				this.runningAnimation = null;
			}
			if (this.insertingAnimation !== null) {
				this.insertingAnimation.remove();
				this.insertingAnimation = null;
			}
		},

		/// INTERNAL FUNCTIONS ///
		useNewAnimation: function() {
			if (this.insertingAnimation !== null) {
				if (this.runningAnimation === null) {
					this.runningAnimation = this.insertingAnimation;
					this.insertingAnimation = null;
					return true;
				} else if (this.insertingAnimation.animationString !== this.runningAnimation.animationString) {
					this.runningAnimation.remove();
					this.runningAnimation = this.insertingAnimation;
					this.insertingAnimation = null;
					return true;
				}
			}
			return false;
		}
	};
};
});

require.define("/robot.applet.js",function(require,module,exports,__dirname,__filename,process,global){/*jshint node:true jquery:true*/
"use strict";

module.exports = function(robot) {

	robot.ProgramApplet = function() { return this.init.apply(this, arguments); };

	robot.ProgramApplet.prototype = {
		init: function($container, options) {
			this.applet = new robot.Applet($container, options);

			if (options.state) this.applet.setState(options.state);
			else this.applet.initialState(options);

			this.program = function() {};
			this.applet.setStateChangeCallback(this.run.bind(this));
			this.run();
		},

		setProgram: function(program) {
			this.program = program;
			this.run();
		},

		run: function() {
			var r = new robot.Robot(this.applet.getState());
			this.applet.clear();
			this.program(r);
			r.play(this.applet);
		}
	};

	robot.Applet = function() { return this.init.apply(this, arguments); };
	robot.Applet.prototype = {
		init: function($container, options) {
			this.readOnly = options.readOnly || false;
			this.blockSize = options.blockSize || 64;

			this.$container = $container;
			this.$container.on('mouseup', this.containerMouseUp.bind(this));
			this.$container.on('mouseleave', this.containerMouseLeave.bind(this));
			this.$container.addClass('robot-container robot-not-highlighting');

			this.$maze = $('<div class="robot-maze"></div>');
			this.$container.append(this.$maze);

			this.$path = $('<div class="robot-path"></div>');
			this.$container.append(this.$path);

			this.$robot = $('<div class="robot-robot"></div>');
			this.$container.append(this.$robot);
			this.$robot.hide();

			this.$initial = $('<div class="robot-robot robot-initial"></div>');
			this.$container.append(this.$initial);
			if (this.blockSize !== 64) {
				robot.setCss3(this.$initial[0], 'transform', 'scale(' + (this.blockSize/64+0.01) + ')');
			}

			if (!this.readOnly) {
				this.$container.addClass('robot-interactive');
				this.$initial.on('mousedown', this.initialMouseDown.bind(this));
			}

			this.animationManager = new robot.RobotAnimationManager(this.$robot, this.$maze, this.blockSize);
			this.animation = null;
		},

		remove: function() {
			this.clear();
			this.$container.children('.robot-maze-block .robot-maze-line-vertical, .robot-maze-line-horizontal').remove();
			this.animationManager.remove();
			this.lastAnim = null;
			this.$lastElement = null;

			this.$maze.remove();
			this.$path.remove();
			this.$robot.remove();
			this.$container.removeClass('robot-container robot-not-highlighting');
		},

		clear: function() {
			this.$path.children('.robot-path-line, .robot-path-point').remove();
			this.animation = this.animationManager.newAnimation();
			this.lastAnim = null;
			this.$lastElement = null;
		},

		insertDelay: function(delay) { // only to be called right after creating this object with a state
			this.lastAnim = {type: 'delay', x: this.state.initialX, y: this.state.initialY, angle: this.state.initialAngle, length: delay};
			this.animation.add(this.lastAnim);
			this.$lastElement = null;
		},

		insertLine: function(fromX, fromY, toX, toY, angle, goals) {
			var dy = (toY-fromY)*this.blockSize, dx = (toX-fromX)*this.blockSize;
			var angleRad = Math.atan2(dy, dx);
			var length = Math.sqrt(dx*dx+dy*dy);
			var $line = $('<div class="robot-path-line"><div class="robot-path-line-inside"></div></div>');
			$line[0].style.width = Math.round(length) + 'px';
			robot.setCss3($line[0], 'transform', 'rotate(' + (angleRad*180/Math.PI) + 'deg)');
			$line[0].style.left = Math.round(fromX*this.blockSize + (this.blockSize + dx - length)/2) + 'px';
			$line[0].style.top = Math.round(fromY*this.blockSize + (this.blockSize + dy)/2) + 'px';
			this.$path.append($line);

			if (goals !== null) {
				for (var i=0; i<goals.length; i++) {
					goals[i].$block = this.$blocks[goals[i].x][goals[i].y];
				}
			}

			this.lastAnim = {type: 'movement', x: fromX, y: fromY, x2: toX, y2: toY, angle: angle, goals: goals};
			this.animation.add(this.lastAnim);

			this.$lastElement = $line;
		},

		insertPoint: function(x, y, fromAngle, amount) {
			var toAngle = fromAngle+amount;
			var $point = $('<div class="robot-path-point"><div class="robot-path-point-inside"><div class="robot-path-point-arrow"></div></div></div>');
			this.$path.append($point);

			var toAngleRad = toAngle/180*Math.PI;

			// 5 = 0.5*@robot-path-point-arrow-hover
			$point[0].style.left = Math.round(x*this.blockSize + this.blockSize/2 + 5*Math.cos(toAngleRad)) + 'px';
			$point[0].style.top = Math.round(y*this.blockSize + this.blockSize/2 - 5*Math.sin(toAngleRad)) + 'px';
			robot.setCss3($point[0], 'transform', 'rotate(' + (-toAngle) + 'deg)');

			this.lastAnim = {type: 'rotation', x: x, y: y, angle: fromAngle, angle2: toAngle};
			this.animation.add(this.lastAnim);

			this.$lastElement = $point;
		},

		insertDetectWall: function(x, y, angle, wall) {
			this.lastAnim = {type: 'wall', x: x, y: y, angle: angle, wall: wall};
			this.animation.add(this.lastAnim);
			this.$lastElement = null;
			return wall;
		},

		removePathHighlights: function() {
			this.$path.children('.robot-path-highlight').removeClass('robot-path-highlight');
		},

		removeEventHighlights: function() {
			this.$path.children('.robot-path-highlight-event').removeClass('robot-path-highlight-event');
		},

		removeTimeHighlights: function() {
			this.$path.children('.robot-path-highlight-time').removeClass('robot-path-highlight-time');
		},

		highlightVisitedGoal: function(goal) {
			this.$maze.children('.robot-maze-block-goal-blink').removeClass('robot-maze-block-goal-blink');
			if (goal !== null) {
				this.$blocks[goal%this.state.columns][Math.floor(goal/this.state.columns)].addClass('robot-maze-block-goal-blink');
			}
		},

		drawInterface: function() {
			var x, y, $line, $block;

			this.width = this.state.columns * this.blockSize;
			this.height = this.state.rows * this.blockSize;
			this.$container.width(this.width);
			this.$container.height(this.height);

			// inits
			this.$maze.children('.robot-maze-block, .robot-maze-line-vertical, .robot-maze-line-horizontal').remove();
			this.$verticalLines = [];
			this.$horizontalLines = [];
			this.$blocks = [];
			for (x=0; x<this.state.columns; x++) {
				this.$verticalLines[x] = [];
				this.$horizontalLines[x] = [];
				this.$blocks[x] = [];
			}

			// blocks
			for (x=0; x<this.state.columns; x++) {
				for (y=0; y<this.state.rows; y++) {
					$block = $('<div class="robot-maze-block"></div>');
					$block[0].style.left = (x*this.blockSize) + 'px';
					$block[0].style.top = (y*this.blockSize) + 'px';
					$block.width(this.blockSize);
					$block.height(this.blockSize);
					$block.data('x', x);
					$block.data('y', y);
					if (this.state.blockGoal[x][y]) $block.addClass('robot-maze-block-goal');
					this.$maze.append($block);
					this.$blocks[x][y] = $block;
				}
			}

			// vertical lines
			for (y=0; y<this.state.rows; y++) {
				for (x=1; x<this.state.columns; x++) {
					$line = $('<div class="robot-maze-line-vertical"><div class="robot-maze-line-inside"></div></div>');
					$line[0].style.left = (x*this.blockSize) + 'px';
					$line[0].style.top = (y*this.blockSize) + 'px';
					$line.height(this.blockSize);
					$line.data('x', x);
					$line.data('y', y);
					if (this.state.verticalActive[x][y]) $line.addClass('robot-maze-line-active');
					this.$maze.append($line);
					this.$verticalLines[x][y] = $line;
				}
			}

			// horizontal lines
			for (x=0; x<this.state.columns; x++) {
				for (y=1; y<this.state.rows; y++) {
					$line = $('<div class="robot-maze-line-horizontal"><div class="robot-maze-line-inside"></div></div>');
					$line[0].style.left = (x*this.blockSize) + 'px';
					$line[0].style.top = (y*this.blockSize) + 'px';
					$line.width(this.blockSize);
					$line.data('x', x);
					$line.data('y', y);
					if (this.state.horizontalActive[x][y]) $line.addClass('robot-maze-line-active');
					this.$maze.append($line);
					this.$horizontalLines[x][y] = {$line: $line, active: false};
				}
			}

			if (!this.readOnly) {
				$('.robot-maze-block').click(this.clickBlock.bind(this));
				$('.robot-maze-line-vertical').click(this.clickVerticalLine.bind(this));
				$('.robot-maze-line-horizontal').click(this.clickHorizontalLine.bind(this));
			}

			this.drawInitial();
		},

		drawInitial: function() {
			this.$initial[0].style.left = (this.state.initialX * this.blockSize + this.blockSize/2) + 'px';
			this.$initial[0].style.top = (this.state.initialY * this.blockSize + this.blockSize/2) + 'px';
		},

		forcePlay: function() {
			this.animationManager.forcePlay(0, Infinity);
		},

		play: function() {
			this.animationManager.play(0, Infinity);
		},

		stop: function() {
			this.animationManager.stop();
		},

		getState: function() {
			return JSON.stringify(this.state);
		},

		setState: function(state) {
			this.state = JSON.parse(state);
			this.drawInterface();
			this.clear();
		},

		initialState: function(options) {
			var columns = options.columns || 8, rows = options.rows || 8;
			this.state = {
				columns: columns,
				rows: rows,
				initialX: Math.floor(columns/2),
				initialY: rows-1,
				initialAngle: 90,
				mazeObjects: 0,
				verticalActive: [],
				horizontalActive: [],
				blockGoal: []
			};
			for (var x=0; x<columns; x++) {
				this.state.verticalActive[x] = [];
				this.state.horizontalActive[x] = [];
				this.state.blockGoal[x] = [];
				for (var y=0; y<rows; y++) {
					this.state.verticalActive[x][y] = false;
					this.state.horizontalActive[x][y] = false;
					this.state.blockGoal[x][y] = false;
				}
			}
		},

		setStateChangeCallback: function(callback) {
			this.stateChangeCallback = callback;
		},

		clickVerticalLine: function(event) {
			var $target = $(event.delegateTarget);
			var active = !this.state.verticalActive[$target.data('x')][$target.data('y')];
			this.state.verticalActive[$target.data('x')][$target.data('y')] = active;
			if (active) {
				this.state.mazeObjects++;
				$target.addClass('robot-maze-line-active');
			} else {
				this.state.mazeObjects--;
				$target.removeClass('robot-maze-line-active');
			}
			this.stateChanged();
		},

		clickHorizontalLine: function(event) {
			var $target = $(event.delegateTarget);
			var active = !this.state.horizontalActive[$target.data('x')][$target.data('y')];
			this.state.horizontalActive[$target.data('x')][$target.data('y')] = active;
			if (active) {
				this.state.mazeObjects++;
				$target.addClass('robot-maze-line-active');
			} else {
				this.state.mazeObjects--;
				$target.removeClass('robot-maze-line-active');
			}
			this.stateChanged();
		},

		clickBlock: function(event) {
			var $target = $(event.delegateTarget);
			var goal = !this.state.blockGoal[$target.data('x')][$target.data('y')];
			this.state.blockGoal[$target.data('x')][$target.data('y')] = goal;
			if (goal) {
				this.state.mazeObjects++;
				$target.addClass('robot-maze-block-goal');
			} else {
				this.state.mazeObjects--;
				$target.removeClass('robot-maze-block-goal');
			}
			this.stateChanged();
		},

		initialMouseDown: function(event) {
			var offset = this.$container.offset();
			if (!this.draggingInitial) {
				this.draggingInitial = true;
				this.dragX = (event.pageX - offset.left)%this.blockSize - this.blockSize/2;
				this.dragY = (event.pageY - offset.top)%this.blockSize - this.blockSize/2;
				this.$container.on('mousemove', this.containerMouseMove.bind(this));
				this.$initial.addClass('robot-initial-dragging');
				event.preventDefault();
				this.drawInitial();
			}
		},

		containerMouseUp: function(event) {
			if (this.draggingInitial) {
				this.$container.off('mousemove');
				this.$initial.removeClass('robot-initial-dragging');
				this.draggingInitial = false;
				this.drawInitial();
			}
		},

		containerMouseLeave: function(event) {
			if (this.draggingInitial) {
				this.$container.off('mousemove');
				this.$initial.removeClass('robot-initial-dragging');
				this.draggingInitial = false;
				this.drawInitial();
			}
		},

		containerMouseMove: function(event) {
			var offset = this.$container.offset();
			var x = Math.floor((event.pageX - offset.left)/this.blockSize);
			var y = Math.floor((event.pageY - offset.top)/this.blockSize);

			if (x !== this.state.initialX || y !== this.state.initialY) {
				this.state.initialX = x;
				this.state.initialY = y;
				this.stateChanged();
			}
			this.$initial[0].style.left = (event.pageX - offset.left - this.dragX) + 'px';
			this.$initial[0].style.top = (event.pageY - offset.top - this.dragY) + 'px';
		},

		stateChanged: function() {
			if (this.stateChangeCallback) {
				this.stateChangeCallback(this.getState());
			}
		}
	};
};

});

require.define("/robot.robot.js",function(require,module,exports,__dirname,__filename,process,global){/*jshint node:true jquery:true*/
"use strict";

module.exports = function(robot) {
	robot.Robot = function() { return this.init.apply(this, arguments); };
	robot.Robot.prototype = {
		init: function(state) {
			this.calls = [];
			this.state = JSON.parse(state);
			this.robotX = this.state.initialX;
			this.robotY = this.state.initialY;
			this.robotAngle = this.state.initialAngle;
			this.visitedGoals = [];
		},

		primitiveDrive: function(name, args, forward) {
			var goals = null, fromX = this.robotX, fromY = this.robotY;
			try {
				var amount = 1;
				if (args[0] !== undefined) {
					amount = args[0];
				}
				if (!forward) amount = -amount;

				if (args.length > 1) {
					throw '<var>' + name + '</var> accepts no more than <var>1</var> argument';
				} else if (typeof amount !== 'number' || !isFinite(amount)) {
					throw 'Argument has to be a valid number';
				} else if (Math.round(amount) !== amount && this.state.mazeObjects > 0) {
					throw 'Fractional amounts are only allowed when the maze is empty';
				} else if (amount !== 0) {
					if (this.state.mazeObjects > 0) {
						var positive = amount > 0;

						for (var i=0; i<Math.abs(amount); i++) {
							if (this.primitiveIsWall(this.robotX, this.robotY, positive ? this.robotAngle : (this.robotAngle + 180)%360)) {
								throw 'Robot ran into a wall';
							}
							if (this.robotAngle === 0) {
								this.robotX += (positive ? 1 : -1);
							} else if (this.robotAngle === 90) {
								this.robotY -= (positive ? 1 : -1);
							} else if (this.robotAngle === 180) {
								this.robotX -= (positive ? 1 : -1);
							} else if (this.robotAngle === 270) {
								this.robotY += (positive ? 1 : -1);
							}
							if (this.state.blockGoal[this.robotX][this.robotY]) {
								var goal = {x: this.robotX, y: this.robotY, amount: i+1};
								if (goals === null) {
									goals = [goal];
								} else {
									goals.push(goal);
								}

								if (this.visitedGoals.indexOf(this.robotX+this.robotY*this.state.columns) < 0) {
									this.visitedGoals.push(this.robotX+this.robotY*this.state.columns);
								}
							}
						}
					} else {
						this.robotX += Math.cos(this.robotAngle / 180 * Math.PI)*amount;
						this.robotY -= Math.sin(this.robotAngle / 180 * Math.PI)*amount;
					}
				}
			} finally {
				this.calls.push({name: 'insertLine', args: [fromX, fromY, this.robotX, this.robotY, this.robotAngle, goals]});
			}
		},

		primitiveTurn: function(name, args, clockwise) {
			var fromAngle = this.robotAngle, amount = 90;
			if (args[0] !== undefined) {
				amount = args[0];
			}

			if (args.length > 1) {
				throw '<var>' + name + '</var> accepts no more than <var>1</var> argument';
			} else if (typeof amount !== 'number' || !isFinite(amount)) {
				throw 'Argument has to be a valid number';
			} else if ([0, 90, 180, 270].indexOf((amount%360+360)%360) < 0 && this.state.mazeObjects > 0) {
				throw 'Only <var>90</var>, <var>180</var> and <var>270</var> degrees are allowed when the maze is not empty';
			} else {
				if (clockwise) amount = -amount;
				this.robotAngle = ((this.robotAngle+amount)%360+360)%360;
			}
			this.calls.push({name: 'insertPoint', args: [this.robotX, this.robotY, fromAngle, amount]});
		},

		primitiveIsWall: function(x, y, angle) {
			if (this.state.mazeObjects <= 0) {
				return false;
			} else {
				if (angle === 0) {
					if (x >= this.state.columns-1 || this.state.verticalActive[x+1][y]) {
						return true;
					}
				} else if (angle === 90) {
					if (y <= 0 || this.state.horizontalActive[x][y]) {
						return true;
					}
				} else if (angle === 180) {
					if (x <= 0 || this.state.verticalActive[x][y]) {
						return true;
					}
				} else if (angle === 270) {
					if (y >= this.state.rows-1 || this.state.horizontalActive[x][y+1]) {
						return true;
					}
				}
				return false;
			}
		},

		primitiveIsGoal: function(x, y) {
			if (this.state.mazeObjects <= 0) return false;
			else return this.state.blockGoal[x][y];
		},

		primitiveDetectWall: function(name, args) {
			var wall = this.primitiveIsWall(this.robotX, this.robotY, this.robotAngle);
			this.calls.push({name: 'insertDetectWall', args: [this.robotX, this.robotY, this.robotAngle, wall]});
			return wall;
		},

		primitiveDetectGoal: function(name, args) {
			return this.primitiveIsGoal(this.robotX, this.robotY);
		},

		drive: function() {
			return this.primitiveDrive('drive', arguments, true);
		},

		turnLeft: function() {
			return this.primitiveTurn('turnLeft', arguments, false);
		},

		turnRight: function() {
			return this.primitiveTurn('turnRight', arguments, true);
		},

		detectWall: function() {
			return this.primitiveDetectWall('detectWall', arguments);
		},

		detectGoal: function() {
			return this.primitiveDetectGoal('detectGoal', arguments);
		},

		getCalls: function() {
			return this.calls;
		},

		play: function(applet) {
			applet.clear();
			for (var i=0; i<this.calls.length; i++) {
				applet[this.calls[i].name].apply(applet, this.calls[i].args);
			}
			applet.play();
		}
	};
/*
	output.Robot = function() { return this.init.apply(this, arguments); };
	output.Robot.prototype = {
		/// INTERNAL FUNCTIONS ///
		initialState: function(options) {
			var columns = options.columns || 8, rows = options.rows || 8;
			this.state = {
				columns: columns,
				rows: rows,
				initialX: Math.floor(columns/2),
				initialY: rows-1,
				initialAngle: 90,
				mazeObjects: 0,
				verticalActive: [],
				horizontalActive: [],
				blockGoal: []
			};
			for (var x=0; x<columns; x++) {
				this.state.verticalActive[x] = [];
				this.state.horizontalActive[x] = [];
				this.state.blockGoal[x] = [];
				for (var y=0; y<rows; y++) {
					this.state.verticalActive[x][y] = false;
					this.state.horizontalActive[x][y] = false;
					this.state.blockGoal[x][y] = false;
				}
			}
		},

		addCall: function(context) {
			if (this.callCounter++ > 300) {
				context.throwTimeout();
			}
			var $element = this.robot.$lastElement;
			if ($element !== null) {
				$element.data('eventPosition', this.eventPosition);
				$element.data('index', this.events[this.eventPosition].calls.length);
				$element.on('mousemove', this.pathMouseMove.bind(this));
				$element.on('mouseleave', this.pathMouseLeave.bind(this));
			}
			this.events[this.eventPosition].calls.push({
				stepNum: context.getStepNum(),
				nodeId: context.getCallNodeId(),
				callId: context.getCallId(),
				$element: $element,
				animNum: this.robot.animation.getLength()-1
			});
			this.events[this.eventPosition].endAnimNum = this.robot.animation.getLength();
		},

		updateInterface: function() {
			if (!this.readOnly) {
				$('.robot-maze-block').click(this.clickBlock.bind(this));
				$('.robot-maze-line-vertical').click(this.clickVerticalLine.bind(this));
				$('.robot-maze-line-horizontal').click(this.clickHorizontalLine.bind(this));
			}
		},

		clickVerticalLine: function(event) {
			var $target = $(event.delegateTarget);
			var active = !this.state.verticalActive[$target.data('x')][$target.data('y')];
			this.state.verticalActive[$target.data('x')][$target.data('y')] = active;
			if (active) {
				this.state.mazeObjects++;
				$target.addClass('robot-maze-line-active');
			} else {
				this.state.mazeObjects--;
				$target.removeClass('robot-maze-line-active');
			}
			this.stateChanged();
		},

		clickHorizontalLine: function(event) {
			var $target = $(event.delegateTarget);
			var active = !this.state.horizontalActive[$target.data('x')][$target.data('y')];
			this.state.horizontalActive[$target.data('x')][$target.data('y')] = active;
			if (active) {
				this.state.mazeObjects++;
				$target.addClass('robot-maze-line-active');
			} else {
				this.state.mazeObjects--;
				$target.removeClass('robot-maze-line-active');
			}
			this.stateChanged();
		},

		pathMouseMove: function(event) {
			if (this.highlighting) {
				var $target = $(event.delegateTarget);
				if ($target.data('eventPosition') === this.eventPosition &&
						this.events[this.eventPosition].calls[$target.data('index')] !== undefined) {
					if (!$target.hasClass('robot-path-highlight')) {
						this.robot.removePathHighlights();
						$target.addClass('robot-path-highlight');
						this.editor.highlightNodeId(this.events[this.eventPosition].calls[$target.data('index')].nodeId);
					}
				} else {
					this.robot.removePathHighlights();
					this.editor.highlightNodeId(0);
				}
			}
		},

		pathMouseLeave: function(event) {
			if (this.highlighting) {
				this.robot.removePathHighlights();
				this.editor.highlightNodeId(0);
			}
		},

		initialMouseDown: function(event) {
			var offset = this.$container.offset();
			if (!this.draggingInitial) {
				this.draggingInitial = true;
				this.dragX = (event.pageX - offset.left)%blockSize - blockSize/2;
				this.dragY = (event.pageY - offset.top)%blockSize - blockSize/2;
				this.$container.on('mousemove', this.containerMouseMove.bind(this));
				this.robot.$initial.addClass('robot-initial-dragging');
				event.preventDefault();
				this.robot.drawInitial();
			}
		},

		containerMouseUp: function(event) {
			if (this.draggingInitial) {
				this.$container.off('mousemove');
				this.robot.$initial.removeClass('robot-initial-dragging');
				this.draggingInitial = false;
				this.robot.drawInitial();
			}
		},

		containerMouseLeave: function(event) {
			if (this.draggingInitial) {
				this.$container.off('mousemove');
				this.robot.$initial.removeClass('robot-initial-dragging');
				this.draggingInitial = false;
				this.robot.drawInitial();
			}
		},

		containerMouseMove: function(event) {
			var offset = this.$container.offset();
			var x = Math.floor((event.pageX - offset.left)/blockSize);
			var y = Math.floor((event.pageY - offset.top)/blockSize);

			if (x !== this.state.initialX || y !== this.state.initialY) {
				this.state.initialX = x;
				this.state.initialY = y;
				this.stateChanged();
			}
			this.robot.$initial.css('left', event.pageX - offset.left - this.dragX);
			this.robot.$initial.css('top', event.pageY - offset.top - this.dragY);
		},

		clickBlock: function(event) {
			var $target = $(event.delegateTarget);
			var goal = !this.state.blockGoal[$target.data('x')][$target.data('y')];
			this.state.blockGoal[$target.data('x')][$target.data('y')] = goal;
			if (goal) {
				this.state.mazeObjects++;
				$target.addClass('robot-maze-block-goal');
			} else {
				this.state.mazeObjects--;
				$target.removeClass('robot-maze-block-goal');
			}
			this.stateChanged();
		},

		stateChanged: function() {
			this.editor.outputRequestsRerun();
			if (this.stateChangeCallback !== null) {
				this.stateChangeCallback(this.getState());
			}
		}
	};*/
};
});

require.define("/index.js",function(require,module,exports,__dirname,__filename,process,global){/*jshint node:true*/
"use strict";

var robot = {};

var firstUpper = function(value) {
	return value[0].toUpperCase() + value.substring(1);
};

robot.setCss3 = function(element, name, value, addBrowserToValue) {
	addBrowserToValue = addBrowserToValue || false;
	var browsers = ['', '', 'moz', 'webkit', 'o'];
	var browsersCSS = ['', '-ms-', '-moz-', '-webkit-', '-o-'];
	for (var i=0; i<browsers.length; i++) {
		var cssName = browsers[i] + firstUpper(name);

		var cssValue = value;
		if (addBrowserToValue && browsersCSS[i])
			cssValue = browsersCSS[i] + value;

		element.style[cssName] = cssValue;
	}
};

require('./robot.animation')(robot);
require('./robot.manager')(robot);
require('./robot.applet')(robot);
require('./robot.robot')(robot);

module.exports = robot;

window.jsdares = window.jsdares || {};
window.jsdares.robot = window.jsdares.robot || robot;

});
require("/index.js");
})();
